# This file was generated by liblab | https://liblab.com/

from typing import List, Union
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..net.transport.request_error import RequestError
from ..models.utils.cast_models import cast_models
from ..models import (
    Contact,
    ContactAddress,
    CreateContact,
    EditAddressPrincipal,
    EditAddressRole,
    EditContact,
    EditContactAgent,
    EditContactInvestor,
    EditContactPersonal,
    EditContactTenant,
    EditContactVendor,
    EditNotes,
)


class CrmContactService(BaseService):

    @cast_models
    def get_contact_async(self, contact_key: str) -> Union[
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        str,
        str,
        bytes,
        str,
    ]:
        """get_contact_async

        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, str, str, bytes, str]
        """

        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/full",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json":
            return Contact._unmap(response)
        if content == "application/xml":
            return Contact._unmap(response)
        if content == "text/plain":
            return Contact._unmap(response)
        if content == "application/octet-stream":
            return Contact._unmap(response)
        if content == "text/json":
            return Contact._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_edit_contact_async(self, contact_key: str) -> Union[
        EditContact,
        EditContact,
        EditContact,
        EditContact,
        EditContact,
        EditContact,
        EditContact,
        EditContact,
        EditContact,
        EditContact,
        EditContact,
        EditContact,
        str,
        str,
        bytes,
        str,
    ]:
        """get_edit_contact_async

        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditContact, EditContact, EditContact, EditContact, EditContact, EditContact, EditContact, EditContact, EditContact, EditContact, EditContact, EditContact, str, str, bytes, str]
        """

        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditContact._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditContact._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditContact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditContact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditContact._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditContact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditContact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditContact._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditContact._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditContact._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditContact._unmap(response)
        if content == "application/json":
            return EditContact._unmap(response)
        if content == "application/xml":
            return EditContact._unmap(response)
        if content == "text/plain":
            return EditContact._unmap(response)
        if content == "application/octet-stream":
            return EditContact._unmap(response)
        if content == "text/json":
            return EditContact._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_edit_contact_async(
        self, contact_key: str, request_body: EditContact = None
    ) -> Union[
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        str,
        str,
        bytes,
        str,
    ]:
        """put_edit_contact_async

        :param request_body: The request body., defaults to None
        :type request_body: EditContact, optional
        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, str, str, bytes, str]
        """

        Validator(EditContact).is_optional().validate(request_body)
        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json":
            return Contact._unmap(response)
        if content == "application/xml":
            return Contact._unmap(response)
        if content == "text/plain":
            return Contact._unmap(response)
        if content == "application/octet-stream":
            return Contact._unmap(response)
        if content == "text/json":
            return Contact._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def delete_contact_async(self, contact_key: str) -> None:
        """delete_contact_async

        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("DELETE")
        )

        self.send_request(serialized_request)

    @cast_models
    def post_contact_async(self, request_body: CreateContact = None) -> Union[
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        str,
        str,
        bytes,
        str,
    ]:
        """post_contact_async

        :param request_body: The request body., defaults to None
        :type request_body: CreateContact, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, str, str, bytes, str]
        """

        Validator(CreateContact).is_optional().validate(request_body)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact", self.get_default_headers()
            )
            .serialize()
            .set_method("POST")
            .set_body(
                request_body,
                "application/json;odata.metadata=minimal;odata.streaming=true",
            )
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json":
            return Contact._unmap(response)
        if content == "application/xml":
            return Contact._unmap(response)
        if content == "text/plain":
            return Contact._unmap(response)
        if content == "application/octet-stream":
            return Contact._unmap(response)
        if content == "text/json":
            return Contact._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_contact_address_async(self, contact_key: str) -> Union[
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        str,
        str,
        bytes,
        str,
    ]:
        """get_contact_address_async

        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], str, str, bytes, str]
        """

        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/address",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/xml":
            return [ContactAddress._unmap(item) for item in response]
        if content == "text/plain":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/octet-stream":
            return [ContactAddress._unmap(item) for item in response]
        if content == "text/json":
            return [ContactAddress._unmap(item) for item in response]
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def post_contact_address_async(
        self, contact_key: str, request_body: EditAddressPrincipal = None
    ) -> Union[
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        str,
        str,
        bytes,
        str,
    ]:
        """post_contact_address_async

        :param request_body: The request body., defaults to None
        :type request_body: EditAddressPrincipal, optional
        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], str, str, bytes, str]
        """

        Validator(EditAddressPrincipal).is_optional().validate(request_body)
        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/address",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("POST")
            .set_body(
                request_body,
                "application/json;odata.metadata=minimal;odata.streaming=true",
            )
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/xml":
            return [ContactAddress._unmap(item) for item in response]
        if content == "text/plain":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/octet-stream":
            return [ContactAddress._unmap(item) for item in response]
        if content == "text/json":
            return [ContactAddress._unmap(item) for item in response]
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_contact_address_async(
        self,
        contact_key: str,
        address_key: str,
        request_body: EditAddressPrincipal = None,
    ) -> Union[
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        str,
        str,
        bytes,
        str,
    ]:
        """put_contact_address_async

        :param request_body: The request body., defaults to None
        :type request_body: EditAddressPrincipal, optional
        :param contact_key: contact_key
        :type contact_key: str
        :param address_key: address_key
        :type address_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], str, str, bytes, str]
        """

        Validator(EditAddressPrincipal).is_optional().validate(request_body)
        Validator(str).validate(contact_key)
        Validator(str).validate(address_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/address/{{addressKey}}",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .add_path("addressKey", address_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/xml":
            return [ContactAddress._unmap(item) for item in response]
        if content == "text/plain":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/octet-stream":
            return [ContactAddress._unmap(item) for item in response]
        if content == "text/json":
            return [ContactAddress._unmap(item) for item in response]
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def delete_contact_address_async(self, contact_key: str, address_key: str) -> Union[
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        str,
        str,
        bytes,
        str,
    ]:
        """delete_contact_address_async

        :param contact_key: contact_key
        :type contact_key: str
        :param address_key: address_key
        :type address_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], str, str, bytes, str]
        """

        Validator(str).validate(contact_key)
        Validator(str).validate(address_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/address/{{addressKey}}",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .add_path("addressKey", address_key)
            .serialize()
            .set_method("DELETE")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/xml":
            return [ContactAddress._unmap(item) for item in response]
        if content == "text/plain":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/octet-stream":
            return [ContactAddress._unmap(item) for item in response]
        if content == "text/json":
            return [ContactAddress._unmap(item) for item in response]
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_contact_address_role_async(
        self, contact_key: str, address_key: str, request_body: EditAddressRole = None
    ) -> Union[
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        List[ContactAddress],
        str,
        str,
        bytes,
        str,
    ]:
        """put_contact_address_role_async

        :param request_body: The request body., defaults to None
        :type request_body: EditAddressRole, optional
        :param contact_key: contact_key
        :type contact_key: str
        :param address_key: address_key
        :type address_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], List[ContactAddress], str, str, bytes, str]
        """

        Validator(EditAddressRole).is_optional().validate(request_body)
        Validator(str).validate(contact_key)
        Validator(str).validate(address_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/address/{{addressKey}}/role",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .add_path("addressKey", address_key)
            .serialize()
            .set_method("PUT")
            .set_body(
                request_body,
                "application/json;odata.metadata=minimal;odata.streaming=true",
            )
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.streaming=true":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json;odata.streaming=false":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/json":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/xml":
            return [ContactAddress._unmap(item) for item in response]
        if content == "text/plain":
            return [ContactAddress._unmap(item) for item in response]
        if content == "application/octet-stream":
            return [ContactAddress._unmap(item) for item in response]
        if content == "text/json":
            return [ContactAddress._unmap(item) for item in response]
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_contact_notes_async(self, contact_key: str) -> Union[
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        str,
        str,
        bytes,
        str,
    ]:
        """get_contact_notes_async

        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, str, str, bytes, str]
        """

        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/notes",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditNotes._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditNotes._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditNotes._unmap(response)
        if content == "application/json":
            return EditNotes._unmap(response)
        if content == "application/xml":
            return EditNotes._unmap(response)
        if content == "text/plain":
            return EditNotes._unmap(response)
        if content == "application/octet-stream":
            return EditNotes._unmap(response)
        if content == "text/json":
            return EditNotes._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_contact_notes_async(
        self, contact_key: str, request_body: EditNotes = None
    ) -> Union[
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        str,
        str,
        bytes,
        str,
    ]:
        """put_contact_notes_async

        :param request_body: The request body., defaults to None
        :type request_body: EditNotes, optional
        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, str, str, bytes, str]
        """

        Validator(EditNotes).is_optional().validate(request_body)
        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/notes",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("PUT")
            .set_body(
                request_body,
                "application/json;odata.metadata=minimal;odata.streaming=true",
            )
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json":
            return Contact._unmap(response)
        if content == "application/xml":
            return Contact._unmap(response)
        if content == "text/plain":
            return Contact._unmap(response)
        if content == "application/octet-stream":
            return Contact._unmap(response)
        if content == "text/json":
            return Contact._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_contact_personal_async(self, contact_key: str) -> Union[
        EditContactPersonal,
        EditContactPersonal,
        EditContactPersonal,
        EditContactPersonal,
        EditContactPersonal,
        EditContactPersonal,
        EditContactPersonal,
        EditContactPersonal,
        EditContactPersonal,
        EditContactPersonal,
        EditContactPersonal,
        EditContactPersonal,
        str,
        str,
        bytes,
        str,
    ]:
        """get_contact_personal_async

        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditContactPersonal, EditContactPersonal, EditContactPersonal, EditContactPersonal, EditContactPersonal, EditContactPersonal, EditContactPersonal, EditContactPersonal, EditContactPersonal, EditContactPersonal, EditContactPersonal, EditContactPersonal, str, str, bytes, str]
        """

        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/personal",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditContactPersonal._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditContactPersonal._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditContactPersonal._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditContactPersonal._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditContactPersonal._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditContactPersonal._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditContactPersonal._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditContactPersonal._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditContactPersonal._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditContactPersonal._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditContactPersonal._unmap(response)
        if content == "application/json":
            return EditContactPersonal._unmap(response)
        if content == "application/xml":
            return EditContactPersonal._unmap(response)
        if content == "text/plain":
            return EditContactPersonal._unmap(response)
        if content == "application/octet-stream":
            return EditContactPersonal._unmap(response)
        if content == "text/json":
            return EditContactPersonal._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_contact_personal_async(
        self, contact_key: str, request_body: EditContactPersonal = None
    ) -> Union[
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        str,
        str,
        bytes,
        str,
    ]:
        """put_contact_personal_async

        :param request_body: The request body., defaults to None
        :type request_body: EditContactPersonal, optional
        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, str, str, bytes, str]
        """

        Validator(EditContactPersonal).is_optional().validate(request_body)
        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/personal",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json":
            return Contact._unmap(response)
        if content == "application/xml":
            return Contact._unmap(response)
        if content == "text/plain":
            return Contact._unmap(response)
        if content == "application/octet-stream":
            return Contact._unmap(response)
        if content == "text/json":
            return Contact._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_contact_agent_async(self, contact_key: str) -> Union[
        EditContactAgent,
        EditContactAgent,
        EditContactAgent,
        EditContactAgent,
        EditContactAgent,
        EditContactAgent,
        EditContactAgent,
        EditContactAgent,
        EditContactAgent,
        EditContactAgent,
        EditContactAgent,
        EditContactAgent,
        str,
        str,
        bytes,
        str,
    ]:
        """get_contact_agent_async

        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditContactAgent, EditContactAgent, EditContactAgent, EditContactAgent, EditContactAgent, EditContactAgent, EditContactAgent, EditContactAgent, EditContactAgent, EditContactAgent, EditContactAgent, EditContactAgent, str, str, bytes, str]
        """

        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/agent",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditContactAgent._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditContactAgent._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditContactAgent._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditContactAgent._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditContactAgent._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditContactAgent._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditContactAgent._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditContactAgent._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditContactAgent._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditContactAgent._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditContactAgent._unmap(response)
        if content == "application/json":
            return EditContactAgent._unmap(response)
        if content == "application/xml":
            return EditContactAgent._unmap(response)
        if content == "text/plain":
            return EditContactAgent._unmap(response)
        if content == "application/octet-stream":
            return EditContactAgent._unmap(response)
        if content == "text/json":
            return EditContactAgent._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_contact_agent_async(
        self, contact_key: str, request_body: EditContactAgent = None
    ) -> Union[
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        str,
        str,
        bytes,
        str,
    ]:
        """put_contact_agent_async

        :param request_body: The request body., defaults to None
        :type request_body: EditContactAgent, optional
        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, str, str, bytes, str]
        """

        Validator(EditContactAgent).is_optional().validate(request_body)
        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/agent",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json":
            return Contact._unmap(response)
        if content == "application/xml":
            return Contact._unmap(response)
        if content == "text/plain":
            return Contact._unmap(response)
        if content == "application/octet-stream":
            return Contact._unmap(response)
        if content == "text/json":
            return Contact._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_contact_investor_async(self, contact_key: str) -> Union[
        EditContactInvestor,
        EditContactInvestor,
        EditContactInvestor,
        EditContactInvestor,
        EditContactInvestor,
        EditContactInvestor,
        EditContactInvestor,
        EditContactInvestor,
        EditContactInvestor,
        EditContactInvestor,
        EditContactInvestor,
        EditContactInvestor,
        str,
        str,
        bytes,
        str,
    ]:
        """put_contact_investor_async

        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditContactInvestor, EditContactInvestor, EditContactInvestor, EditContactInvestor, EditContactInvestor, EditContactInvestor, EditContactInvestor, EditContactInvestor, EditContactInvestor, EditContactInvestor, EditContactInvestor, EditContactInvestor, str, str, bytes, str]
        """

        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/investor",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditContactInvestor._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditContactInvestor._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditContactInvestor._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditContactInvestor._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditContactInvestor._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditContactInvestor._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditContactInvestor._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditContactInvestor._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditContactInvestor._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditContactInvestor._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditContactInvestor._unmap(response)
        if content == "application/json":
            return EditContactInvestor._unmap(response)
        if content == "application/xml":
            return EditContactInvestor._unmap(response)
        if content == "text/plain":
            return EditContactInvestor._unmap(response)
        if content == "application/octet-stream":
            return EditContactInvestor._unmap(response)
        if content == "text/json":
            return EditContactInvestor._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_contact_investor_async_put_api_v1_crm_contact_contact_key_investor(
        self, contact_key: str, request_body: EditContactInvestor = None
    ) -> Union[
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        str,
        str,
        bytes,
        str,
    ]:
        """put_contact_investor_async_put_api_v1_crm_contact_contact_key_investor

        :param request_body: The request body., defaults to None
        :type request_body: EditContactInvestor, optional
        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, str, str, bytes, str]
        """

        Validator(EditContactInvestor).is_optional().validate(request_body)
        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/investor",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json":
            return Contact._unmap(response)
        if content == "application/xml":
            return Contact._unmap(response)
        if content == "text/plain":
            return Contact._unmap(response)
        if content == "application/octet-stream":
            return Contact._unmap(response)
        if content == "text/json":
            return Contact._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_contact_tenant_async(self, contact_key: str) -> Union[
        EditContactTenant,
        EditContactTenant,
        EditContactTenant,
        EditContactTenant,
        EditContactTenant,
        EditContactTenant,
        EditContactTenant,
        EditContactTenant,
        EditContactTenant,
        EditContactTenant,
        EditContactTenant,
        EditContactTenant,
        str,
        str,
        bytes,
        str,
    ]:
        """get_contact_tenant_async

        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditContactTenant, EditContactTenant, EditContactTenant, EditContactTenant, EditContactTenant, EditContactTenant, EditContactTenant, EditContactTenant, EditContactTenant, EditContactTenant, EditContactTenant, EditContactTenant, str, str, bytes, str]
        """

        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/tenant",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditContactTenant._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditContactTenant._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditContactTenant._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditContactTenant._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditContactTenant._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditContactTenant._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditContactTenant._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditContactTenant._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditContactTenant._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditContactTenant._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditContactTenant._unmap(response)
        if content == "application/json":
            return EditContactTenant._unmap(response)
        if content == "application/xml":
            return EditContactTenant._unmap(response)
        if content == "text/plain":
            return EditContactTenant._unmap(response)
        if content == "application/octet-stream":
            return EditContactTenant._unmap(response)
        if content == "text/json":
            return EditContactTenant._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_contact_tenant_async(
        self, contact_key: str, request_body: EditContactTenant = None
    ) -> Union[
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        str,
        str,
        bytes,
        str,
    ]:
        """put_contact_tenant_async

        :param request_body: The request body., defaults to None
        :type request_body: EditContactTenant, optional
        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, str, str, bytes, str]
        """

        Validator(EditContactTenant).is_optional().validate(request_body)
        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/tenant",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json":
            return Contact._unmap(response)
        if content == "application/xml":
            return Contact._unmap(response)
        if content == "text/plain":
            return Contact._unmap(response)
        if content == "application/octet-stream":
            return Contact._unmap(response)
        if content == "text/json":
            return Contact._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_contact_vendor_async(self, contact_key: str) -> Union[
        EditContactVendor,
        EditContactVendor,
        EditContactVendor,
        EditContactVendor,
        EditContactVendor,
        EditContactVendor,
        EditContactVendor,
        EditContactVendor,
        EditContactVendor,
        EditContactVendor,
        EditContactVendor,
        EditContactVendor,
        str,
        str,
        bytes,
        str,
    ]:
        """get_contact_vendor_async

        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditContactVendor, EditContactVendor, EditContactVendor, EditContactVendor, EditContactVendor, EditContactVendor, EditContactVendor, EditContactVendor, EditContactVendor, EditContactVendor, EditContactVendor, EditContactVendor, str, str, bytes, str]
        """

        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/vendor",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditContactVendor._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditContactVendor._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditContactVendor._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditContactVendor._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditContactVendor._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditContactVendor._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditContactVendor._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditContactVendor._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditContactVendor._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditContactVendor._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditContactVendor._unmap(response)
        if content == "application/json":
            return EditContactVendor._unmap(response)
        if content == "application/xml":
            return EditContactVendor._unmap(response)
        if content == "text/plain":
            return EditContactVendor._unmap(response)
        if content == "application/octet-stream":
            return EditContactVendor._unmap(response)
        if content == "text/json":
            return EditContactVendor._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_contact_vendor_async(
        self, contact_key: str, request_body: EditContactVendor = None
    ) -> Union[
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        Contact,
        str,
        str,
        bytes,
        str,
    ]:
        """put_contact_vendor_async

        :param request_body: The request body., defaults to None
        :type request_body: EditContactVendor, optional
        :param contact_key: contact_key
        :type contact_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, Contact, str, str, bytes, str]
        """

        Validator(EditContactVendor).is_optional().validate(request_body)
        Validator(str).validate(contact_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/contact/{{contactKey}}/vendor",
                self.get_default_headers(),
            )
            .add_path("contactKey", contact_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Contact._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Contact._unmap(response)
        if content == "application/json":
            return Contact._unmap(response)
        if content == "application/xml":
            return Contact._unmap(response)
        if content == "text/plain":
            return Contact._unmap(response)
        if content == "application/octet-stream":
            return Contact._unmap(response)
        if content == "text/json":
            return Contact._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)
