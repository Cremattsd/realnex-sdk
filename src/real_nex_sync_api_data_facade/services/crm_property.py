# This file was generated by liblab | https://liblab.com/

from typing import Union
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..net.transport.request_error import RequestError
from ..models.utils.cast_models import cast_models
from ..models import (
    CreateProperty,
    EditNotes,
    EditProperty,
    EditPropertyDetails,
    EditPropertyListingForLease,
    EditPropertyListingForSale,
    EditPropertyUsage,
    Property,
)


class CrmPropertyService(BaseService):

    @cast_models
    def get_property_async(self, property_key: str) -> Union[
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        str,
        str,
        bytes,
        str,
    ]:
        """get_property_async

        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, str, str, bytes, str]
        """

        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}/full",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json":
            return Property._unmap(response)
        if content == "application/xml":
            return Property._unmap(response)
        if content == "text/plain":
            return Property._unmap(response)
        if content == "application/octet-stream":
            return Property._unmap(response)
        if content == "text/json":
            return Property._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def post_property_async(self, request_body: CreateProperty = None) -> Union[
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        str,
        str,
        bytes,
        str,
    ]:
        """post_property_async

        :param request_body: The request body., defaults to None
        :type request_body: CreateProperty, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, str, str, bytes, str]
        """

        Validator(CreateProperty).is_optional().validate(request_body)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property", self.get_default_headers()
            )
            .serialize()
            .set_method("POST")
            .set_body(
                request_body,
                "application/json;odata.metadata=minimal;odata.streaming=true",
            )
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json":
            return Property._unmap(response)
        if content == "application/xml":
            return Property._unmap(response)
        if content == "text/plain":
            return Property._unmap(response)
        if content == "application/octet-stream":
            return Property._unmap(response)
        if content == "text/json":
            return Property._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_edit_property_async(self, property_key: str) -> Union[
        EditProperty,
        EditProperty,
        EditProperty,
        EditProperty,
        EditProperty,
        EditProperty,
        EditProperty,
        EditProperty,
        EditProperty,
        EditProperty,
        EditProperty,
        EditProperty,
        str,
        str,
        bytes,
        str,
    ]:
        """get_edit_property_async

        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditProperty, EditProperty, EditProperty, EditProperty, EditProperty, EditProperty, EditProperty, EditProperty, EditProperty, EditProperty, EditProperty, EditProperty, str, str, bytes, str]
        """

        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditProperty._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditProperty._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditProperty._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditProperty._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditProperty._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditProperty._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditProperty._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditProperty._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditProperty._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditProperty._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditProperty._unmap(response)
        if content == "application/json":
            return EditProperty._unmap(response)
        if content == "application/xml":
            return EditProperty._unmap(response)
        if content == "text/plain":
            return EditProperty._unmap(response)
        if content == "application/octet-stream":
            return EditProperty._unmap(response)
        if content == "text/json":
            return EditProperty._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_edit_property_async(
        self, property_key: str, request_body: EditProperty = None
    ) -> Union[
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        str,
        str,
        bytes,
        str,
    ]:
        """put_edit_property_async

        :param request_body: The request body., defaults to None
        :type request_body: EditProperty, optional
        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, str, str, bytes, str]
        """

        Validator(EditProperty).is_optional().validate(request_body)
        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json":
            return Property._unmap(response)
        if content == "application/xml":
            return Property._unmap(response)
        if content == "text/plain":
            return Property._unmap(response)
        if content == "application/octet-stream":
            return Property._unmap(response)
        if content == "text/json":
            return Property._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def delete_property_async(self, property_key: str) -> Union[
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        str,
        str,
        bytes,
        str,
    ]:
        """delete_property_async

        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, str, str, bytes, str]
        """

        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("DELETE")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json":
            return Property._unmap(response)
        if content == "application/xml":
            return Property._unmap(response)
        if content == "text/plain":
            return Property._unmap(response)
        if content == "application/octet-stream":
            return Property._unmap(response)
        if content == "text/json":
            return Property._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_property_notes_async(self, property_key: str) -> Union[
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        str,
        str,
        bytes,
        str,
    ]:
        """get_property_notes_async

        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, str, str, bytes, str]
        """

        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}/notes",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditNotes._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditNotes._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditNotes._unmap(response)
        if content == "application/json":
            return EditNotes._unmap(response)
        if content == "application/xml":
            return EditNotes._unmap(response)
        if content == "text/plain":
            return EditNotes._unmap(response)
        if content == "application/octet-stream":
            return EditNotes._unmap(response)
        if content == "text/json":
            return EditNotes._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_property_notes_async(
        self, property_key: str, request_body: EditNotes = None
    ) -> Union[
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        str,
        str,
        bytes,
        str,
    ]:
        """put_property_notes_async

        :param request_body: The request body., defaults to None
        :type request_body: EditNotes, optional
        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, str, str, bytes, str]
        """

        Validator(EditNotes).is_optional().validate(request_body)
        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}/notes",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("PUT")
            .set_body(
                request_body,
                "application/json;odata.metadata=minimal;odata.streaming=true",
            )
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json":
            return Property._unmap(response)
        if content == "application/xml":
            return Property._unmap(response)
        if content == "text/plain":
            return Property._unmap(response)
        if content == "application/octet-stream":
            return Property._unmap(response)
        if content == "text/json":
            return Property._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_property_details_async(self, property_key: str) -> Union[
        EditPropertyDetails,
        EditPropertyDetails,
        EditPropertyDetails,
        EditPropertyDetails,
        EditPropertyDetails,
        EditPropertyDetails,
        EditPropertyDetails,
        EditPropertyDetails,
        EditPropertyDetails,
        EditPropertyDetails,
        EditPropertyDetails,
        EditPropertyDetails,
        str,
        str,
        bytes,
        str,
    ]:
        """get_property_details_async

        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditPropertyDetails, EditPropertyDetails, EditPropertyDetails, EditPropertyDetails, EditPropertyDetails, EditPropertyDetails, EditPropertyDetails, EditPropertyDetails, EditPropertyDetails, EditPropertyDetails, EditPropertyDetails, EditPropertyDetails, str, str, bytes, str]
        """

        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}/details",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditPropertyDetails._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditPropertyDetails._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditPropertyDetails._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditPropertyDetails._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditPropertyDetails._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditPropertyDetails._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditPropertyDetails._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditPropertyDetails._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditPropertyDetails._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditPropertyDetails._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditPropertyDetails._unmap(response)
        if content == "application/json":
            return EditPropertyDetails._unmap(response)
        if content == "application/xml":
            return EditPropertyDetails._unmap(response)
        if content == "text/plain":
            return EditPropertyDetails._unmap(response)
        if content == "application/octet-stream":
            return EditPropertyDetails._unmap(response)
        if content == "text/json":
            return EditPropertyDetails._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_property_details_async(
        self, property_key: str, request_body: EditPropertyDetails = None
    ) -> Union[
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        str,
        str,
        bytes,
        str,
    ]:
        """put_property_details_async

        :param request_body: The request body., defaults to None
        :type request_body: EditPropertyDetails, optional
        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, str, str, bytes, str]
        """

        Validator(EditPropertyDetails).is_optional().validate(request_body)
        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}/details",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json":
            return Property._unmap(response)
        if content == "application/xml":
            return Property._unmap(response)
        if content == "text/plain":
            return Property._unmap(response)
        if content == "application/octet-stream":
            return Property._unmap(response)
        if content == "text/json":
            return Property._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_property_usage_async(self, property_key: str) -> Union[
        EditPropertyUsage,
        EditPropertyUsage,
        EditPropertyUsage,
        EditPropertyUsage,
        EditPropertyUsage,
        EditPropertyUsage,
        EditPropertyUsage,
        EditPropertyUsage,
        EditPropertyUsage,
        EditPropertyUsage,
        EditPropertyUsage,
        EditPropertyUsage,
        str,
        str,
        bytes,
        str,
    ]:
        """get_property_usage_async

        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditPropertyUsage, EditPropertyUsage, EditPropertyUsage, EditPropertyUsage, EditPropertyUsage, EditPropertyUsage, EditPropertyUsage, EditPropertyUsage, EditPropertyUsage, EditPropertyUsage, EditPropertyUsage, EditPropertyUsage, str, str, bytes, str]
        """

        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}/usage",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditPropertyUsage._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditPropertyUsage._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditPropertyUsage._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditPropertyUsage._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditPropertyUsage._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditPropertyUsage._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditPropertyUsage._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditPropertyUsage._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditPropertyUsage._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditPropertyUsage._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditPropertyUsage._unmap(response)
        if content == "application/json":
            return EditPropertyUsage._unmap(response)
        if content == "application/xml":
            return EditPropertyUsage._unmap(response)
        if content == "text/plain":
            return EditPropertyUsage._unmap(response)
        if content == "application/octet-stream":
            return EditPropertyUsage._unmap(response)
        if content == "text/json":
            return EditPropertyUsage._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_property_usage_async(
        self, property_key: str, request_body: EditPropertyUsage = None
    ) -> Union[
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        str,
        str,
        bytes,
        str,
    ]:
        """put_property_usage_async

        :param request_body: The request body., defaults to None
        :type request_body: EditPropertyUsage, optional
        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, str, str, bytes, str]
        """

        Validator(EditPropertyUsage).is_optional().validate(request_body)
        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}/usage",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json":
            return Property._unmap(response)
        if content == "application/xml":
            return Property._unmap(response)
        if content == "text/plain":
            return Property._unmap(response)
        if content == "application/octet-stream":
            return Property._unmap(response)
        if content == "text/json":
            return Property._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_property_listing_for_lease_async(self, property_key: str) -> Union[
        EditPropertyListingForLease,
        EditPropertyListingForLease,
        EditPropertyListingForLease,
        EditPropertyListingForLease,
        EditPropertyListingForLease,
        EditPropertyListingForLease,
        EditPropertyListingForLease,
        EditPropertyListingForLease,
        EditPropertyListingForLease,
        EditPropertyListingForLease,
        EditPropertyListingForLease,
        EditPropertyListingForLease,
        str,
        str,
        bytes,
        str,
    ]:
        """get_property_listing_for_lease_async

        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditPropertyListingForLease, EditPropertyListingForLease, EditPropertyListingForLease, EditPropertyListingForLease, EditPropertyListingForLease, EditPropertyListingForLease, EditPropertyListingForLease, EditPropertyListingForLease, EditPropertyListingForLease, EditPropertyListingForLease, EditPropertyListingForLease, EditPropertyListingForLease, str, str, bytes, str]
        """

        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}/listingforlease",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditPropertyListingForLease._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditPropertyListingForLease._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditPropertyListingForLease._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditPropertyListingForLease._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditPropertyListingForLease._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditPropertyListingForLease._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditPropertyListingForLease._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditPropertyListingForLease._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditPropertyListingForLease._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditPropertyListingForLease._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditPropertyListingForLease._unmap(response)
        if content == "application/json":
            return EditPropertyListingForLease._unmap(response)
        if content == "application/xml":
            return EditPropertyListingForLease._unmap(response)
        if content == "text/plain":
            return EditPropertyListingForLease._unmap(response)
        if content == "application/octet-stream":
            return EditPropertyListingForLease._unmap(response)
        if content == "text/json":
            return EditPropertyListingForLease._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_property_listing_for_lease_async(
        self, property_key: str, request_body: EditPropertyListingForLease = None
    ) -> Union[
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        str,
        str,
        bytes,
        str,
    ]:
        """put_property_listing_for_lease_async

        :param request_body: The request body., defaults to None
        :type request_body: EditPropertyListingForLease, optional
        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, str, str, bytes, str]
        """

        Validator(EditPropertyListingForLease).is_optional().validate(request_body)
        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}/listingforlease",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json":
            return Property._unmap(response)
        if content == "application/xml":
            return Property._unmap(response)
        if content == "text/plain":
            return Property._unmap(response)
        if content == "application/octet-stream":
            return Property._unmap(response)
        if content == "text/json":
            return Property._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_property_listing_for_sale_async(self, property_key: str) -> Union[
        EditPropertyListingForSale,
        EditPropertyListingForSale,
        EditPropertyListingForSale,
        EditPropertyListingForSale,
        EditPropertyListingForSale,
        EditPropertyListingForSale,
        EditPropertyListingForSale,
        EditPropertyListingForSale,
        EditPropertyListingForSale,
        EditPropertyListingForSale,
        EditPropertyListingForSale,
        EditPropertyListingForSale,
        str,
        str,
        bytes,
        str,
    ]:
        """get_property_listing_for_sale_async

        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditPropertyListingForSale, EditPropertyListingForSale, EditPropertyListingForSale, EditPropertyListingForSale, EditPropertyListingForSale, EditPropertyListingForSale, EditPropertyListingForSale, EditPropertyListingForSale, EditPropertyListingForSale, EditPropertyListingForSale, EditPropertyListingForSale, EditPropertyListingForSale, str, str, bytes, str]
        """

        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}/listingforsale",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditPropertyListingForSale._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditPropertyListingForSale._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditPropertyListingForSale._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditPropertyListingForSale._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditPropertyListingForSale._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditPropertyListingForSale._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditPropertyListingForSale._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditPropertyListingForSale._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditPropertyListingForSale._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditPropertyListingForSale._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditPropertyListingForSale._unmap(response)
        if content == "application/json":
            return EditPropertyListingForSale._unmap(response)
        if content == "application/xml":
            return EditPropertyListingForSale._unmap(response)
        if content == "text/plain":
            return EditPropertyListingForSale._unmap(response)
        if content == "application/octet-stream":
            return EditPropertyListingForSale._unmap(response)
        if content == "text/json":
            return EditPropertyListingForSale._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_property_listing_for_sale_async(
        self, property_key: str, request_body: EditPropertyListingForSale = None
    ) -> Union[
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        Property,
        str,
        str,
        bytes,
        str,
    ]:
        """put_property_listing_for_sale_async

        :param request_body: The request body., defaults to None
        :type request_body: EditPropertyListingForSale, optional
        :param property_key: property_key
        :type property_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, Property, str, str, bytes, str]
        """

        Validator(EditPropertyListingForSale).is_optional().validate(request_body)
        Validator(str).validate(property_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/property/{{propertyKey}}/listingforsale",
                self.get_default_headers(),
            )
            .add_path("propertyKey", property_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Property._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Property._unmap(response)
        if content == "application/json":
            return Property._unmap(response)
        if content == "application/xml":
            return Property._unmap(response)
        if content == "text/plain":
            return Property._unmap(response)
        if content == "application/octet-stream":
            return Property._unmap(response)
        if content == "text/json":
            return Property._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)
