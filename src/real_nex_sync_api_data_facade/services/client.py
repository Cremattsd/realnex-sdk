# This file was generated by liblab | https://liblab.com/

from typing import Union
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..net.transport.request_error import RequestError
from ..models.utils.cast_models import cast_models
from ..models import ClientCallbacks, ClientInfo, ClientRetrySettings


class ClientService(BaseService):

    @cast_models
    def get_user(self, api_version: str = None) -> Union[
        ClientInfo,
        ClientInfo,
        ClientInfo,
        ClientInfo,
        ClientInfo,
        ClientInfo,
        ClientInfo,
        ClientInfo,
        ClientInfo,
        ClientInfo,
        ClientInfo,
        ClientInfo,
        str,
        str,
        bytes,
        str,
    ]:
        """get_user

        :param api_version: The requested API version, defaults to None
        :type api_version: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[ClientInfo, ClientInfo, ClientInfo, ClientInfo, ClientInfo, ClientInfo, ClientInfo, ClientInfo, ClientInfo, ClientInfo, ClientInfo, ClientInfo, str, str, bytes, str]
        """

        Validator(str).is_optional().validate(api_version)

        serialized_request = (
            Serializer(f"{self.base_url}/api/Client", self.get_default_headers())
            .add_query("api-version", api_version)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return ClientInfo._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return ClientInfo._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return ClientInfo._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return ClientInfo._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return ClientInfo._unmap(response)
        if content == "application/json;odata.metadata=full":
            return ClientInfo._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return ClientInfo._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return ClientInfo._unmap(response)
        if content == "application/json;odata.metadata=none":
            return ClientInfo._unmap(response)
        if content == "application/json;odata.streaming=true":
            return ClientInfo._unmap(response)
        if content == "application/json;odata.streaming=false":
            return ClientInfo._unmap(response)
        if content == "application/json":
            return ClientInfo._unmap(response)
        if content == "application/xml":
            return ClientInfo._unmap(response)
        if content == "text/plain":
            return ClientInfo._unmap(response)
        if content == "application/octet-stream":
            return ClientInfo._unmap(response)
        if content == "text/json":
            return ClientInfo._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_user_callbacks(self, api_version: str = None) -> Union[
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        str,
        str,
        bytes,
        str,
    ]:
        """get_user_callbacks

        :param api_version: The requested API version, defaults to None
        :type api_version: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, str, str, bytes, str]
        """

        Validator(str).is_optional().validate(api_version)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/Client/callbacks", self.get_default_headers()
            )
            .add_query("api-version", api_version)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=full":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=none":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.streaming=true":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.streaming=false":
            return ClientCallbacks._unmap(response)
        if content == "application/json":
            return ClientCallbacks._unmap(response)
        if content == "application/xml":
            return ClientCallbacks._unmap(response)
        if content == "text/plain":
            return ClientCallbacks._unmap(response)
        if content == "application/octet-stream":
            return ClientCallbacks._unmap(response)
        if content == "text/json":
            return ClientCallbacks._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def post_user_callbacks(
        self, request_body: ClientCallbacks = None, api_version: str = None
    ) -> Union[
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        ClientCallbacks,
        str,
        str,
        bytes,
        str,
    ]:
        """post_user_callbacks

        :param request_body: The request body., defaults to None
        :type request_body: ClientCallbacks, optional
        :param api_version: The requested API version, defaults to None
        :type api_version: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, ClientCallbacks, str, str, bytes, str]
        """

        Validator(ClientCallbacks).is_optional().validate(request_body)
        Validator(str).is_optional().validate(api_version)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/Client/callbacks", self.get_default_headers()
            )
            .add_query("api-version", api_version)
            .serialize()
            .set_method("POST")
            .set_body(
                request_body,
                "application/json;odata.metadata=minimal;odata.streaming=true",
            )
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=full":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.metadata=none":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.streaming=true":
            return ClientCallbacks._unmap(response)
        if content == "application/json;odata.streaming=false":
            return ClientCallbacks._unmap(response)
        if content == "application/json":
            return ClientCallbacks._unmap(response)
        if content == "application/xml":
            return ClientCallbacks._unmap(response)
        if content == "text/plain":
            return ClientCallbacks._unmap(response)
        if content == "application/octet-stream":
            return ClientCallbacks._unmap(response)
        if content == "text/json":
            return ClientCallbacks._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_user_retry_settings(self, api_version: str = None) -> Union[
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        str,
        str,
        bytes,
        str,
    ]:
        """get_user_retry_settings

        :param api_version: The requested API version, defaults to None
        :type api_version: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, str, str, bytes, str]
        """

        Validator(str).is_optional().validate(api_version)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/Client/retrysettings", self.get_default_headers()
            )
            .add_query("api-version", api_version)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=full":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=none":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.streaming=true":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.streaming=false":
            return ClientRetrySettings._unmap(response)
        if content == "application/json":
            return ClientRetrySettings._unmap(response)
        if content == "application/xml":
            return ClientRetrySettings._unmap(response)
        if content == "text/plain":
            return ClientRetrySettings._unmap(response)
        if content == "application/octet-stream":
            return ClientRetrySettings._unmap(response)
        if content == "text/json":
            return ClientRetrySettings._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def post_user_retry_settings(
        self, request_body: ClientRetrySettings = None, api_version: str = None
    ) -> Union[
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        ClientRetrySettings,
        str,
        str,
        bytes,
        str,
    ]:
        """post_user_retry_settings

        :param request_body: The request body., defaults to None
        :type request_body: ClientRetrySettings, optional
        :param api_version: The requested API version, defaults to None
        :type api_version: str, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, ClientRetrySettings, str, str, bytes, str]
        """

        Validator(ClientRetrySettings).is_optional().validate(request_body)
        Validator(str).is_optional().validate(api_version)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/Client/retrysettings", self.get_default_headers()
            )
            .add_query("api-version", api_version)
            .serialize()
            .set_method("POST")
            .set_body(
                request_body,
                "application/json;odata.metadata=minimal;odata.streaming=true",
            )
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=full":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.metadata=none":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.streaming=true":
            return ClientRetrySettings._unmap(response)
        if content == "application/json;odata.streaming=false":
            return ClientRetrySettings._unmap(response)
        if content == "application/json":
            return ClientRetrySettings._unmap(response)
        if content == "application/xml":
            return ClientRetrySettings._unmap(response)
        if content == "text/plain":
            return ClientRetrySettings._unmap(response)
        if content == "application/octet-stream":
            return ClientRetrySettings._unmap(response)
        if content == "text/json":
            return ClientRetrySettings._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)
