# This file was generated by liblab | https://liblab.com/

from typing import List, Union
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..net.transport.request_error import RequestError
from ..models.utils.cast_models import cast_models
from ..models import (
    CreateProject,
    EditNotes,
    EditProject,
    EditProjectDetails,
    EditProjectLead,
    EditProjectLeadJsonMergePatchDocument,
    LeadObjectType,
    Project,
    ProjectLead,
    ProjectLeadSorting,
)


class CrmProjectService(BaseService):

    @cast_models
    def get_project_async(self, project_key: str) -> Union[
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        str,
        str,
        bytes,
        str,
    ]:
        """get_project_async

        :param project_key: project_key
        :type project_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, str, str, bytes, str]
        """

        Validator(str).validate(project_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project/{{projectKey}}/full",
                self.get_default_headers(),
            )
            .add_path("projectKey", project_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Project._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json":
            return Project._unmap(response)
        if content == "application/xml":
            return Project._unmap(response)
        if content == "text/plain":
            return Project._unmap(response)
        if content == "application/octet-stream":
            return Project._unmap(response)
        if content == "text/json":
            return Project._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def post_project_async(self, request_body: CreateProject = None) -> Union[
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        str,
        str,
        bytes,
        str,
    ]:
        """post_project_async

        :param request_body: The request body., defaults to None
        :type request_body: CreateProject, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, str, str, bytes, str]
        """

        Validator(CreateProject).is_optional().validate(request_body)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project", self.get_default_headers()
            )
            .serialize()
            .set_method("POST")
            .set_body(
                request_body,
                "application/json;odata.metadata=minimal;odata.streaming=true",
            )
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Project._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json":
            return Project._unmap(response)
        if content == "application/xml":
            return Project._unmap(response)
        if content == "text/plain":
            return Project._unmap(response)
        if content == "application/octet-stream":
            return Project._unmap(response)
        if content == "text/json":
            return Project._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_edit_project_async(self, project_key: str) -> Union[
        EditProject,
        EditProject,
        EditProject,
        EditProject,
        EditProject,
        EditProject,
        EditProject,
        EditProject,
        EditProject,
        EditProject,
        EditProject,
        EditProject,
        str,
        str,
        bytes,
        str,
    ]:
        """get_edit_project_async

        :param project_key: project_key
        :type project_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditProject, EditProject, EditProject, EditProject, EditProject, EditProject, EditProject, EditProject, EditProject, EditProject, EditProject, EditProject, str, str, bytes, str]
        """

        Validator(str).validate(project_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project/{{projectKey}}",
                self.get_default_headers(),
            )
            .add_path("projectKey", project_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditProject._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditProject._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditProject._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditProject._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditProject._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditProject._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditProject._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditProject._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditProject._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditProject._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditProject._unmap(response)
        if content == "application/json":
            return EditProject._unmap(response)
        if content == "application/xml":
            return EditProject._unmap(response)
        if content == "text/plain":
            return EditProject._unmap(response)
        if content == "application/octet-stream":
            return EditProject._unmap(response)
        if content == "text/json":
            return EditProject._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_project_async(
        self, project_key: str, request_body: EditProject = None
    ) -> Union[
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        str,
        str,
        bytes,
        str,
    ]:
        """put_project_async

        :param request_body: The request body., defaults to None
        :type request_body: EditProject, optional
        :param project_key: project_key
        :type project_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, str, str, bytes, str]
        """

        Validator(EditProject).is_optional().validate(request_body)
        Validator(str).validate(project_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project/{{projectKey}}",
                self.get_default_headers(),
            )
            .add_path("projectKey", project_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Project._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json":
            return Project._unmap(response)
        if content == "application/xml":
            return Project._unmap(response)
        if content == "text/plain":
            return Project._unmap(response)
        if content == "application/octet-stream":
            return Project._unmap(response)
        if content == "text/json":
            return Project._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def delete_project_async(
        self, project_key: str
    ) -> Union[
        str, str, str, str, str, str, str, str, str, str, str, str, str, str, bytes, str
    ]:
        """delete_project_async

        :param project_key: project_key
        :type project_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[str, str, str, str, str, str, str, str, str, str, str, str, str, str, bytes, str]
        """

        Validator(str).validate(project_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project/{{projectKey}}",
                self.get_default_headers(),
            )
            .add_path("projectKey", project_key)
            .serialize()
            .set_method("DELETE")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return response
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return response
        if content == "application/json;odata.metadata=minimal":
            return response
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return response
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return response
        if content == "application/json;odata.metadata=full":
            return response
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return response
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return response
        if content == "application/json;odata.metadata=none":
            return response
        if content == "application/json;odata.streaming=true":
            return response
        if content == "application/json;odata.streaming=false":
            return response
        if content == "application/json":
            return response
        if content == "application/xml":
            return response
        if content == "text/plain":
            return response
        if content == "application/octet-stream":
            return response
        if content == "text/json":
            return response
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_edit_project_notes_async(self, project_key: str) -> Union[
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        EditNotes,
        str,
        str,
        bytes,
        str,
    ]:
        """get_edit_project_notes_async

        :param project_key: project_key
        :type project_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, EditNotes, str, str, bytes, str]
        """

        Validator(str).validate(project_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project/{{projectKey}}/notes",
                self.get_default_headers(),
            )
            .add_path("projectKey", project_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditNotes._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditNotes._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditNotes._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditNotes._unmap(response)
        if content == "application/json":
            return EditNotes._unmap(response)
        if content == "application/xml":
            return EditNotes._unmap(response)
        if content == "text/plain":
            return EditNotes._unmap(response)
        if content == "application/octet-stream":
            return EditNotes._unmap(response)
        if content == "text/json":
            return EditNotes._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_project_notes_async(
        self, project_key: str, request_body: EditNotes = None
    ) -> Union[
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        str,
        str,
        bytes,
        str,
    ]:
        """put_project_notes_async

        :param request_body: The request body., defaults to None
        :type request_body: EditNotes, optional
        :param project_key: project_key
        :type project_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, str, str, bytes, str]
        """

        Validator(EditNotes).is_optional().validate(request_body)
        Validator(str).validate(project_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project/{{projectKey}}/notes",
                self.get_default_headers(),
            )
            .add_path("projectKey", project_key)
            .serialize()
            .set_method("PUT")
            .set_body(
                request_body,
                "application/json;odata.metadata=minimal;odata.streaming=true",
            )
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Project._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json":
            return Project._unmap(response)
        if content == "application/xml":
            return Project._unmap(response)
        if content == "text/plain":
            return Project._unmap(response)
        if content == "application/octet-stream":
            return Project._unmap(response)
        if content == "text/json":
            return Project._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_edit_project_details_async(self, project_key: str) -> Union[
        EditProjectDetails,
        EditProjectDetails,
        EditProjectDetails,
        EditProjectDetails,
        EditProjectDetails,
        EditProjectDetails,
        EditProjectDetails,
        EditProjectDetails,
        EditProjectDetails,
        EditProjectDetails,
        EditProjectDetails,
        EditProjectDetails,
        str,
        str,
        bytes,
        str,
    ]:
        """get_edit_project_details_async

        :param project_key: project_key
        :type project_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditProjectDetails, EditProjectDetails, EditProjectDetails, EditProjectDetails, EditProjectDetails, EditProjectDetails, EditProjectDetails, EditProjectDetails, EditProjectDetails, EditProjectDetails, EditProjectDetails, EditProjectDetails, str, str, bytes, str]
        """

        Validator(str).validate(project_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project/{{projectKey}}/details",
                self.get_default_headers(),
            )
            .add_path("projectKey", project_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditProjectDetails._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditProjectDetails._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditProjectDetails._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditProjectDetails._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditProjectDetails._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditProjectDetails._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditProjectDetails._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditProjectDetails._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditProjectDetails._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditProjectDetails._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditProjectDetails._unmap(response)
        if content == "application/json":
            return EditProjectDetails._unmap(response)
        if content == "application/xml":
            return EditProjectDetails._unmap(response)
        if content == "text/plain":
            return EditProjectDetails._unmap(response)
        if content == "application/octet-stream":
            return EditProjectDetails._unmap(response)
        if content == "text/json":
            return EditProjectDetails._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_project_details_async(
        self, project_key: str, request_body: EditProjectDetails = None
    ) -> Union[
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        Project,
        str,
        str,
        bytes,
        str,
    ]:
        """put_project_details_async

        :param request_body: The request body., defaults to None
        :type request_body: EditProjectDetails, optional
        :param project_key: project_key
        :type project_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, Project, str, str, bytes, str]
        """

        Validator(EditProjectDetails).is_optional().validate(request_body)
        Validator(str).validate(project_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project/{{projectKey}}/details",
                self.get_default_headers(),
            )
            .add_path("projectKey", project_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body, "application/merge-patch+json")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=full":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json;odata.metadata=none":
            return Project._unmap(response)
        if content == "application/json;odata.streaming=true":
            return Project._unmap(response)
        if content == "application/json;odata.streaming=false":
            return Project._unmap(response)
        if content == "application/json":
            return Project._unmap(response)
        if content == "application/xml":
            return Project._unmap(response)
        if content == "text/plain":
            return Project._unmap(response)
        if content == "application/octet-stream":
            return Project._unmap(response)
        if content == "text/json":
            return Project._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_project_leads_async(
        self,
        project_key: str,
        object_types: List[LeadObjectType] = None,
        order: ProjectLeadSorting = None,
        page_size: int = None,
        page_number: int = None,
    ) -> Union[
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        str,
        str,
        bytes,
        str,
    ]:
        """get_project_leads_async

        :param project_key: project_key
        :type project_key: str
        :param object_types: object_types, defaults to None
        :type object_types: List[LeadObjectType], optional
        :param order: order, defaults to None
        :type order: ProjectLeadSorting, optional
        :param page_size: page_size, defaults to None
        :type page_size: int, optional
        :param page_number: page_number, defaults to None
        :type page_number: int, optional
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], str, str, bytes, str]
        """

        Validator(str).validate(project_key)
        Validator(LeadObjectType).is_array().is_optional().validate(object_types)
        Validator(ProjectLeadSorting).is_optional().validate(order)
        Validator(int).is_optional().validate(page_size)
        Validator(int).is_optional().validate(page_number)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project/{{projectKey}}/lead",
                self.get_default_headers(),
            )
            .add_path("projectKey", project_key)
            .add_query("ObjectTypes", object_types)
            .add_query("Order", order)
            .add_query("PageSize", page_size)
            .add_query("PageNumber", page_number)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/xml":
            return [ProjectLead._unmap(item) for item in response]
        if content == "text/plain":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/octet-stream":
            return [ProjectLead._unmap(item) for item in response]
        if content == "text/json":
            return [ProjectLead._unmap(item) for item in response]
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def post_project_lead_async(
        self, project_key: str, request_body: EditProjectLead = None
    ) -> Union[
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        str,
        str,
        bytes,
        str,
    ]:
        """post_project_lead_async

        :param request_body: The request body., defaults to None
        :type request_body: EditProjectLead, optional
        :param project_key: project_key
        :type project_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], str, str, bytes, str]
        """

        Validator(EditProjectLead).is_optional().validate(request_body)
        Validator(str).validate(project_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project/{{projectKey}}/lead",
                self.get_default_headers(),
            )
            .add_path("projectKey", project_key)
            .serialize()
            .set_method("POST")
            .set_body(
                request_body,
                "application/json;odata.metadata=minimal;odata.streaming=true",
            )
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/xml":
            return [ProjectLead._unmap(item) for item in response]
        if content == "text/plain":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/octet-stream":
            return [ProjectLead._unmap(item) for item in response]
        if content == "text/json":
            return [ProjectLead._unmap(item) for item in response]
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def get_project_lead_async(self, project_key: str, lead_key: str) -> Union[
        EditProjectLead,
        EditProjectLead,
        EditProjectLead,
        EditProjectLead,
        EditProjectLead,
        EditProjectLead,
        EditProjectLead,
        EditProjectLead,
        EditProjectLead,
        EditProjectLead,
        EditProjectLead,
        EditProjectLead,
        str,
        str,
        bytes,
        str,
    ]:
        """get_project_lead_async

        :param project_key: project_key
        :type project_key: str
        :param lead_key: lead_key
        :type lead_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[EditProjectLead, EditProjectLead, EditProjectLead, EditProjectLead, EditProjectLead, EditProjectLead, EditProjectLead, EditProjectLead, EditProjectLead, EditProjectLead, EditProjectLead, EditProjectLead, str, str, bytes, str]
        """

        Validator(str).validate(project_key)
        Validator(str).validate(lead_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project/{{projectKey}}/lead/{{leadKey}}",
                self.get_default_headers(),
            )
            .add_path("projectKey", project_key)
            .add_path("leadKey", lead_key)
            .serialize()
            .set_method("GET")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return EditProjectLead._unmap(response)
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return EditProjectLead._unmap(response)
        if content == "application/json;odata.metadata=minimal":
            return EditProjectLead._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return EditProjectLead._unmap(response)
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return EditProjectLead._unmap(response)
        if content == "application/json;odata.metadata=full":
            return EditProjectLead._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return EditProjectLead._unmap(response)
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return EditProjectLead._unmap(response)
        if content == "application/json;odata.metadata=none":
            return EditProjectLead._unmap(response)
        if content == "application/json;odata.streaming=true":
            return EditProjectLead._unmap(response)
        if content == "application/json;odata.streaming=false":
            return EditProjectLead._unmap(response)
        if content == "application/json":
            return EditProjectLead._unmap(response)
        if content == "application/xml":
            return EditProjectLead._unmap(response)
        if content == "text/plain":
            return EditProjectLead._unmap(response)
        if content == "application/octet-stream":
            return EditProjectLead._unmap(response)
        if content == "text/json":
            return EditProjectLead._unmap(response)
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def put_project_lead_async(
        self,
        project_key: str,
        lead_key: str,
        request_body: EditProjectLeadJsonMergePatchDocument = None,
    ) -> Union[
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        str,
        str,
        bytes,
        str,
    ]:
        """put_project_lead_async

        :param request_body: The request body., defaults to None
        :type request_body: EditProjectLeadJsonMergePatchDocument, optional
        :param project_key: project_key
        :type project_key: str
        :param lead_key: lead_key
        :type lead_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], str, str, bytes, str]
        """

        Validator(EditProjectLeadJsonMergePatchDocument).is_optional().validate(
            request_body
        )
        Validator(str).validate(project_key)
        Validator(str).validate(lead_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project/{{projectKey}}/lead/{{leadKey}}",
                self.get_default_headers(),
            )
            .add_path("projectKey", project_key)
            .add_path("leadKey", lead_key)
            .serialize()
            .set_method("PUT")
            .set_body(request_body)
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/xml":
            return [ProjectLead._unmap(item) for item in response]
        if content == "text/plain":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/octet-stream":
            return [ProjectLead._unmap(item) for item in response]
        if content == "text/json":
            return [ProjectLead._unmap(item) for item in response]
        raise RequestError("Error on deserializing the response.", status, response)

    @cast_models
    def delete_project_lead_async(self, project_key: str, lead_key: str) -> Union[
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        List[ProjectLead],
        str,
        str,
        bytes,
        str,
    ]:
        """delete_project_lead_async

        :param project_key: project_key
        :type project_key: str
        :param lead_key: lead_key
        :type lead_key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: The parsed response data.
        :rtype: Union[List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], List[ProjectLead], str, str, bytes, str]
        """

        Validator(str).validate(project_key)
        Validator(str).validate(lead_key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/Crm/project/{{projectKey}}/lead/{{leadKey}}",
                self.get_default_headers(),
            )
            .add_path("projectKey", project_key)
            .add_path("leadKey", lead_key)
            .serialize()
            .set_method("DELETE")
        )

        response, status, content = self.send_request(serialized_request)
        if content == "application/json;odata.metadata=minimal;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=minimal":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=full":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.metadata=none":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.streaming=true":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json;odata.streaming=false":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/json":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/xml":
            return [ProjectLead._unmap(item) for item in response]
        if content == "text/plain":
            return [ProjectLead._unmap(item) for item in response]
        if content == "application/octet-stream":
            return [ProjectLead._unmap(item) for item in response]
        if content == "text/json":
            return [ProjectLead._unmap(item) for item in response]
        raise RequestError("Error on deserializing the response.", status, response)
